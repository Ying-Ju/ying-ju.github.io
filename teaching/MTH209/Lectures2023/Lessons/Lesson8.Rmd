---
title: "MTH 209 Data Manipulation and Management"
subtitle: "Lesson 8: Data Manipulation with R Package tidyverse" 
author: |
  | Department of Mathematics
  | University of Dayton
bibliography: ../styles/MTH209.bib
link-citations: yes
output: 
  slidy_presentation:
    css: ["../styles/fonts.css", "../styles/mytheme.css"]
    font_adjustment: -1
---
  
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      cache = TRUE,
                      cache.lazy = TRUE,
                      out.width = "100%",
                      warning = FALSE,
                      message = FALSE,
                      progress = FALSE,
                      verbose = TRUE)
```


## Overview - 1

<head>
    <base target="_blank">
</head>

In this session, we will talk about data manipulation using R package <span Style="Color:red">tidyverse</span>. This lecture is based on [R for Data Science](https://r4ds.had.co.nz/).

<span Style="Color:red">tidyverse</span> contains a collection of R packages that help us doing data management & exploration. The key packages in tidyverse are:

  - dplyr: data manipulation
  - ggplot2: data visualization 
  - purr: functional programming toolkit
  - readr: read data and write files
  - tibble: simple data frame
  - tidyr: data management
  
  
## Overview - 2

In this session, we will focus on the following key functions in <span Style="Color:red">dplyr</span> using the dataset **flights** from the R package <span Style="color:red">nycflights13</span>.

  - filter(): pick observations by their values
  - arrange(): reorder the rows
  - select(): select variables by their names
  - mutate(): create new variables with functions of existing variables 
  - group_by(): group data by existing variables
  - summarize(): collapse many values done to a single summary (with group_by)

\

All functions above work similarly. 

1. The first argument is a data frame. 
2. The subsequent arguments describe what to do with the data frame using the variable names.
3. The result is a new data frame (but we can save it back to the original data frame if needed).

## Load packages and read the Flights Data

First, we load the necessary packages, check conflict functions, and import the dataset **flights** from the R package <span Style="color:red">nycflights13</span>. 

```{r loading_packages, cache=FALSE}
library(tidyverse)
library(conflicted)
conflict_prefer("select", "dplyr")
conflict_prefer("filter", "dplyr")
df <- nycflights13::flights
```

## Understand Our Data

Now we need to understand the data and each variable before we move on. This dataset provides on-time data for all flights that departed NYC (i.e. JFK, LGA or EWR) in 2013 and there are 19 variables ([Flights Data](https://rdrr.io/cran/nycflights13/man/flights.html){target="_blank"}). 

  - year, month, day: Date of departure.
  - dep_time, arr_time: Actual departure and arrival times (format HHMM or HMM), local time zone.
  - sched_dep_time, sched_arr_time: Scheduled departure and arrival times (format HHMM or HMM), local time zone.
  - dep_delay, arr_delay: Departure and arrival delays, in minutes. Negative times represent early departures/arrivals.
  - carrier: Two letter carrier abbreviation. See airlines to get name.
  - flight: Flight number.
  - tailnum: Plane tail number. See planes for additional metadata.
  - origin, dest: Origin and destination. See airports for additional metadata.
  - air_time: Amount of time spent in the air, in minutes.
  - distance: Distance between airports, in miles.
  - hour, minute: Time of scheduled departure broken into hour and minutes.
  - time_hour: Scheduled date and hour of the flight as a POSIXct date. Along with origin, can be used to join flights data to weather data.

## Get a Glimpse of the Data

We get a glimpse of the data. 

```{r glimpse}
glimpse(df)
```

## filter() - 1
  
<span Style="color:blue">filter()</span> is used when we want to subset observations based on a logical condition. For example, we can select all fights on December 25th using the following code. 

```{r filter_christmas}
Christmas <- filter(df, month == 12, day == 25)
```

<span Style="color:orange">Comparisons</span> - R provides the standard suite: <, <=, >, >=, != (not equal), and == (equal). If we would like to save the results to a variable as well as print them, we can wrap the assignment in parentheses

```{r filter_firstday}
(Jan1 <- filter(df, month == 1, day == 1))
```

## filter() - 2

<span Style="color:orange">Logical Operations</span> - R provides the following syntax: & is "and", | is "or", ! is "not". The following code finds all flights that departed in July or August. 

```{r filter_summer_departed}
flights0708 <- filter(df, month == 7 | month == 8)
# only shows the first 5 rows and 10 columns in the data
head(filter(df, month %in% c(7, 8)), c(5, 10))
```

**Note:** 

1. If we use <span Style="color:blue">filter(df, month == 7 | 8)</span>, it finds all months are equal 7 | 8, an expression that evaluates to **TRUE**. In a numeric context, TRUE becomes one, so this finds all fights in the data. 
2. <span Style="color:blue">filter()</span> only includes rows where the condition is **TRUE** and it excludes both FALSE and NA values. 

## filter() - 3

If we want to find flights that weren't delayed on both arrival and departure by more than 1 hour, we could use either of the following codes. 

```{r filter_nodelays1}
filter(df, !(arr_delay > 60 | dep_delay > 60))
```

```{r filter_nodelays2, eval=FALSE}
filter(df, arr_delay <= 60, dep_delay <= 60)
```

## arrange() - 1

<span Style="color:blue">arrange()</span> is used when we want to sort a dataset by a variable. If more variables are specified for sorting a dataset, the variables entered first taking priority over those come later. The following code chunk gives an example that sorts the flights by dates.  

```{r arrange_dates}
arrange(df, year, month, day)
```

## arrange() - 2

**Note:** 
1. We can save the data frame back to the original data frame after sorting the data.
2. Use <span Style=:color:blue>desc()</span> for sorting data via descending order. The following code chunk arranges the Flights Data by arrival delay in descending order.
3. Missing values are always sorted at the end.

```{r arrange_arr_delay}
df <- arrange(df, desc(arr_delay))
```

We can use the <span Style="color:blue">tail()</span> function to read the last part of the data. 

```{r arrange_arr_delay_check}
tail(df, 5)
```


## select()

<span Style="color:blue">select()</span> is used when we would like to obtain several variables in the data. For example, we can use the following code chunk to select the Flights Data with only a few variables. 

```{r select1, eval=FALSE}
# select specific columns
select(df, year, month, day)

# select all columns between year and day
select(df, year:day) 

# select all columns except those from year and day
select(df, -(year:day)) 
```

**Note:**

1. We can use a minus sign - to drop variables. 
2. There are several helper functions we can use within <span Style="color:blue">select()</span>. See <span Style="color:blue">?select</span> for the information. 
3. <span Style="color:blue">select()</span> can be used with the <span Style="color:blue">everything()</span> function when we have a handful of variables we would like to move to the start of the data frame. 


```{r select2, eval=FALSE}
# move carrier, origin, dest, and distance to the start of the data
select(df, carrier, origin, dest, distance, everything())
```


## mutate() - 1

<span Style="color:blue">mutate()</span> is used when we would like to add a new variable / column using the other variables in the data. 

**Note:**  <span Style="color:blue">mutate()</span> always adds new columns at the end of the data. 

First, we start by creating a smaller dataset with a few variables and create two variables using varaibles in the dataset. 

```{r mutate}
# we start by creating a smaller dataset.
df1 <- select(df, year:day, ends_with("delay"), distance, air_time)
df1 <- mutate(df1, 
       gain= arr_delay - dep_delay, 
       speed = distance / air_time * 60,
       hours = air_time / 60,
       gain_per_hour = gain / hours)
head(df1, c(5, 11))
```

## mutate() - 2

If we only want to keep the new variables, use <span Style="color:blue">transmute()</span>. 

```{r transmute}
transmute(df1, 
       gain= arr_delay - dep_delay, 
       speed = distance / air_time * 60,
       hours = air_time / 60,
       gain_per_hour = gain / hours)
```

**Note:** There are many functions for creating new variables that we can use with <span Style="color:blue">mutate()</span>. The key property is that the function must be vectorized, which means it must take a vector of values as input and returns a vector with the same number of values as output. 



## summarize() - 1

<span Style="color:blue">summarize()</span> collapses a data frame to a single row. For example, we can summarize the average departure delays using the following code chunk.

```{r summarize}
summarize(df, delay = mean(dep_delay, na.rm=T))
```

## group_by() & summarize() - 1

In general, <span Style="color:blue">summarize()</span> function is used together with <span Style="color:blue">group_by()</span> as we group rows for some purposes. <span Style="color:blue">group_by()</span> is used to group rows by one or more variables, giving priority to the variable entered first. 

```{r groupby1}
group_by(df, year, month, day)
```

The result shows the original data but indicates groups: year, month, day, in our example. 

## group_by() & summarize() - 2

For example, we can study the average departure / arrival delays for each day. 

```{r groupby2}
by_day <- group_by(df, year, month, day) 
summarize(by_day, 
          ave_dep_delay = mean(dep_delay, na.rm = T),
          ave_arr_delay = mean(arr_delay, na.rm = T)
          )
```


## Combining Multiple Operations with the Pipe - 1

In other to handle the data processing well in data science, it is essential to know the use of pipes. Pipes are great tool for presenting a sequence of multiple operations and therefore, pipes increase readability of the code. The pipe, %>%, is from the package <span Style="color:red">magrittr</span> and it is loaded automatically when tidyverse is loaded. 

The logic when using pipe: <span Style="color:orange">object %>% function1 %>% function 2....</span> 

If we want to group the Flights Data by the destination and then find the number of flights, the average distance, the average arrival delay at each destination, and filter to remove Honolulu airport (HNL), we may use the following code chunk to achieve this. 

```{r groupby3}
by_dest <- group_by(df, dest)
delay <- summarize(by_dest,
                   count = n(),
                   ave_dist = mean(distance, na.rm=T),
                   ave_arr_delay = mean(arr_delay, na.rm=T))
delay <- filter(delay, count > 20, dest != "HNL")
```

The following code chunk does the same task with the pipe, %>% and it makes the code easier to read. 

```{r pipe}
delay <- df %>% 
  group_by(dest) %>%
  summarize(
    count = n(),
    ave_dist = mean(distance, na.rm=T),
    ave_arr_delay = mean(arr_delay, na.rm=T)
    ) %>%
  filter(count > 20, dest != "HNL")
```

## Useful Summary Functions - 1

- Measures of location for a quantitative variable: <span Style="color:blue"> mean()</span>, <span Style="color:blue"> median()</span>

- Measure of spread for a quantitative variable: <span Style="color:blue">sd()</span>, <span Style="color:blue"> IQR()</span>, <span Style="color:blue">mad()</span>

Here, $MAD = median(|x_i-\bar{x}|)$ is called the median absolute deviation which may be more useful if we have outliers. 


```{r summary1}
not_cancelled <- df %>% 
  filter(!is.na(dep_delay), !is.na(arr_delay))

not_cancelled_summary <- not_cancelled %>% 
  group_by(dest) %>%
  summarize(
    distance_mu = mean(distance),
    distance_sd = sd(distance)) %>%
  arrange(desc(distance_sd))

head(not_cancelled_summary, 5)
```

## Useful Summary Functions - 2

- Measures of rank: <span Style="color:blue">min()</span>, <span Style="color:blue">quantile()</span>, <span Style="color:blue">max()</span>

```{r summary2}
not_cancelled %>%
  group_by(year, month, day) %>%
  summarize(
    first = min(dep_time), # the first flight departed each day
    last = max(dep_time) # the last flight departed each day
  )
```

## Useful Summary Functions - 3

- Measures of position: <span Style="color:blue">first()</span>, <span Style="color:blue">nth(x, 2)</span>, <span Style="color:blue">last()</span>

The following code chunk finds the first and last departure for each day

```{r summary3}
not_cancelled %>%
  group_by(year, month, day) %>%
  summarize(
    first_dep = first(dep_time),
    last_dep = last(dep_time)
  )
```

## Useful Summary Functions - 4

- Counts: You have seen <span Style="color:blue">n()</span>, which takes no arguments, and returns the size of the current group. To count the nubmer of non-missing values, we can use <span Style="color:blue">sum(is.na(x))</span>. To count the number of distinct values, use <span Style="color:blue">n_distinct()</span>.

```{r counts1}
not_cancelled %>%
  group_by(dest) %>%
  summarize(carriers = n_distinct(carrier)) %>%
  arrange(desc(carriers))
```

## Useful Summary Functions - 5

We can use <span Style="color:blue">count()</span> directly if all we want is a count. 

```{r counts2}
not_cancelled_count <- not_cancelled %>% 
  count(dest)
head(not_cancelled_count, 4)
```

We can optionally provide a weight variable. For example we could use this to "count" the total number of miles a plane flew.

```{r counts3}
not_cancelled_weight <- not_cancelled %>%
  count(tailnum, wt = distance)
head(not_cancelled_weight, 4)
```

## Useful Summary Functions - 6

- Counts and proportions of logical values

When used with numeric functions, TRUE is converted to 1 and FALSE to 0. Thus, <span Style="color:blue">sum()</span> gives the number of TRUEs and <span Style="color:blue">mean()</span> gives the proportion in the variable. For example, we can check how many flights left before 5AM using the following code chunk. 

```{r counts4}
not_cancelled %>%
  group_by(year, month, day) %>%
  summarize(n_early = sum(dep_time < 500))
```

## Useful Summary Functions - 7

Or what proportion of flights are delayed by more than one hour?

```{r count5}
not_cancelled %>%
  group_by(year, month, day) %>%
  summarize(hour_perc = mean(arr_delay > 60))
```

## Grouping by Multiple Variables - 1 

Here we show some examples to demonstrate how to group the data by multiple variables. 

```{r groupby_more1}
per_day <- df %>% 
   group_by(year, month, day) %>%
  summarize(flights = n())
per_month <- summarize(per_day, flights = sum(flights))
per_year <- summarize(per_month, flights = sum(flights))

head(per_month, 3)
per_year
```

## Ungrouping

If we need to remove grouping, and return to operations on ungrouped data, use <span Style="color:blue">ungroup()</span>.

```{r ungroup}
daily <- df %>% group_by(year, month, day)
daily %>% 
  ungroup() %>% # no longer grouped by date
  summarize(flights=n()) # all flights
```


## Grouped Mutates and Filters - 1

We can also do convenient operations with <span Style="color:blue">mutate()</span> and <span Style="color:blue">filter()</span>.

The following code chunk finds the worst members of each group. 
```{r worst_member}
df1 %>% 
  group_by(year, month, day) %>% 
  filter(rank(desc(arr_delay)) < 10)
```

## Grouped Mutates and Filters - 2

The following code chunk finds all groups bigger than a threshold. 

```{r popular_dest}
popular_dests <- df %>%
  group_by(dest) %>% 
  filter(n()>365)
popular_dests
```

## Grouped Mutates and Filters - 3

The following code chunk standardizes to compute per group metrics. 

```{r standardized}
popular_dests %>% 
  filter(arr_delay > 0) %>% 
  mutate(prop_delay = arr_delay / sum(arr_delay)) %>% 
  select(year:day, arr_delay, prop_delay)
``` 

## Some Useful Functions

- <span Style="color:blue">drop_na()</span>: drops rows contain a missing value. 

|       **Usage**: <span Style="color:blue">drop_na(data, ...)<span>


- <span Style="color:blue">rename()</span>: renames columns 

|       **Usage**: <span Style="color:blue">rename(.data, ...)<span>


- <span Style="color:blue">recode()</span>: replaces numeric values based on their position, and replaces character values by their name. Usage: <span Style="color:orange">.default</span>, if supplied, gives all cases not matched a new value. <span Style="color:orange">.missing</span> replaces the missing values by the specified new value.

|       **Usage**: <span Style="color:blue">recode(.x, ..., .default = NULL, .missing = NULL)<span>

- <span Style="color:blue">case_when()</span>: a general vectorised if

|       **Usage**: <span Style="color:blue">case_when(...)<span>


## drop_na() function

We can use the <span Style="color:blue">drop_na()<span> function to drop rows containing missing values. 

```{r drop_na}
nrow(df)
df <- df %>% drop_na()
nrow(df)
```

## rename() function

We can use the <span Style="color:blue">rename()<span> function to rename column names. This function makes the task much easier since we can rename a variable directly without knowing which column that variable is. 

```{r rename}
df <- df %>% rename(
  DepTime = dep_time,
  SchedDepTime = sched_dep_time, 
  DepDelay = dep_delay,
  ArrTime = arr_time, 
  SchedArrTime = sched_arr_time,
  ArrDelay = arr_delay
)

colnames(df)
```


## recode() function

We might want to recode specific values in an R data frame sometimes. The <span Style="color:blue">recode()(</span> function from the <span Style="color:red">dplyr package</span> makes this simple to accomplish.

```{r recode1}
df$month <- recode(df$month, 
                   `1` = "Jan",
                   `2` = "Feb",
                   `3` = "Mar",
                   `4` = "Apr")
unique(df$month)
```

We should pay attention to the data type of a variable. In the example above, the original data type is integer and it becomes character after we recode some values. This is due to unreplaced values treated as NA as `.x` is not compatible.

```{r number_recode}
x  <- c(12, 31, 0, 34, 8, 5, 7, 16, 8)
x <- x %>% recode(`0` = 1314)
x
```
## case_when() function


We can use <span Style="color:blue">case_when()(</span> function to create a new variable with the <span Style="color:blue">mutate()(</span> function together. 

```{r case_when}
df <- df %>% mutate(arr_status = case_when(
  ArrDelay > 60 ~ "LongDelay",
  ArrDelay > 0 & ArrDelay <= 60 ~ "Delay",
  ArrDelay == 0  ~ "OnTime",
  ArrDelay < 0 ~ "NotDelay",
  is.na(ArrDelay) ~ "Unknown"
))

count(df, arr_status)
```



## README

You can utilize the following single character keyboard shortcuts to enable alternate display modes (@xie2018r):

* A: Switches show of current versus all slides (helpful for printing all pages)

* B: Make fonts large

* c: Show table of contents

* S: Make fonts smaller





