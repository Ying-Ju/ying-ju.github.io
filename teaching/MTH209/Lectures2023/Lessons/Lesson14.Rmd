---
title: "MTH 209 Data Manipulation and Management"
subtitle: "Lesson 14: The apply() Family of Functions" 
author: |
  | Department of Mathematics
  | University of Dayton
bibliography: ../styles/MTH209.bib
link-citations: yes
output: 
  slidy_presentation:
    css: ["../styles/fonts.css", "../styles/mytheme.css"]
    font_adjustment: -1
---
  
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      cache = TRUE,
                      cache.lazy = TRUE,
                      out.width = "100%",
                      warning = FALSE,
                      message = FALSE,
                      progress = FALSE,
                      verbose = TRUE)
```

## Overview

<head>
    <base target="_blank">
</head>

In this session, we will introduce the <span Style="color:blue">apply()</span> family of functions. 

### What are these apply() family of functions?

- The <span Style="color:blue">apply()</span> function applies a function over array margins

- The <span Style="color:blue">lapply()</span> function applies a function over a list or vector

- The <span Style="color:blue">sapply()</span> function is a user-friendly version and wrapper of <span Style="color:blue">lapply()</span> by simplifying the output to the most elementary data structure that is possible. 

- The <span Style="color:blue">vapply()</span> function is similar to the <span Style="color:blue">sapply()</span> function, but has a pre-specified type of return value. 

- The <span Style="color:blue">mapply()</span> function is a multivariate version of the <span Style="color:blue">supply()</span> function.

- The <span Style="color:blue">rapply()</span> function recursively applies a function to a list

- The <span Style="color:blue">tapply()</span> function applies a function over a ragged array

**Note:** This lesson is based on the book: The Art of R Programming (@matloff2011art). 


## apply()

- Usage

```{}
apply(X, MARGIN, FUN, ..., simplify = TRUE)
```

Let's create a matrix first.

```{r matrix}
mymatrix <- matrix(1:18, ncol=6)
```

Then we can find the summary statistics for each row of the matrix using the following code chunk. 

```{r rowsum}
apply(mymatrix, 1, summary)
```

We can find the mean value of each column in the matrix using the following code chunk.

```{r colsum}
apply(mymatrix, 2, mean)
```


## lapply()

- Usage

```{}
lapply(X, FUN, ...)
```

We create a list first. 

```{r list}
mylist <- list(A = matrix(1:18, nrow=3), B = rnorm(1000, 10, 1), C = rexp(100, rate=3))
```

We can find the sum of each component in the list.

```{r lapply}
lapply(mylist, sum)
```

We can see how the results are saved as a list form. If we want to have the result saved in a vector, we can use the<span Style="color:blue">unlist()</span> function. 

```{r unlist}
unlist(lapply(mylist, sum))
```

## sapply()

- Usage

```{}
sapply(X, FUN, ..., simplify = TRUE, USE.NAMES = TRUE)
```

An example using the same object <span Style="color:orange">mylist</span> is given below. 
```{r sapply}
sapply(mylist, sum)
```

Here is another example. 

```{r sapply2}
sapply(1:10, function(x) c(x, x^2))
```

## vapply()

- Usage

```{}
vapply(X, FUN, FUN.VALUE, ..., USE.NAMES = TRUE)
```

Let's create a new list. Then we apply the <span Style="color:blue">sapply()</span> function to the list.


```{r newlist}
mylist <- list(A = matrix(1:18, nrow=3), B = rnorm(1000, 10, 1), C = rexp(100, rate=3), D = letters[1:5])
sapply(mylist, max)
```

We can add an extra parameter that specifies the data type expected for the function being applied in the <span Style="color:blue">vapply()</span> function. 


```{r vapply1, error=TRUE}
vapply(mylist, max, numeric(1))
```

**Note:** numeric(1) specifies that we want to have individual numeric values.

```{r vapply2}
mylist$D <- NULL
vapply(mylist, max, numeric(1), simplify=FALSE)
```

## mapply()

- Usage

```{}
mapply(FUN, ..., MoreArgs = NULL, SIMPLIFY = TRUE, USE.NAMES = TRUE)
```

The following example shows how we can replicate 1 at 2 times, 2 at 1 time, 3 at 3 times, and 4 at 5 times.

```{r mapply}
mapply(rep, 1:4, c(2, 1, 3, 5))
```

The following code chunk shows that given two vectors $x$ and $y$, we can find $xsin(y)$ for each ordered pair $(x,y)$. 

```{r mapply2}
round(mapply(function(x,y) x*sin(y), x=1:10, y=seq(pi/10, pi, pi/10)), 2)
```

## rapply() - 1

- Usage

```{}
rapply(object, f, classes = "ANY", deflt = NULL, how = c("unlist", "replace", "list"), ...)
```

This function has three basic modes. Let's see the following examples using the list object <span Style="color:orange">mylist</span> we created before.

### Using replace mode

```{r replace}
mylist$D <- letters[1:5]
rapply(mylist, mean, how = "replace", classes = "numeric")
```

If <span Style="color:orange">how = "replace"</span>, each element of the list object which is not itself list-like and has a class included in classes is replaced by the result of applying f to the element.

## rapply() - 2

### Using list mode

```{r listmode}
rapply(mylist, mean, how = "list", classes = "numeric")
```
 
### Using unlist mode

```{r unlistmode}
rapply(mylist, mean, how = "unlist", classes = "numeric")
```
 
## tapply()

- Usage

```{}
tapply(X, INDEX, FUN = NULL, ..., default = NA, simplify = TRUE)
```

Let's use mtcars dataset as an example. The following code chunk shows how we can find 
the maximum mile per gallon by the different number of cylinders. 

```{r tapply}
tapply(mtcars$mpg, mtcars$cyl, max)
```

## README

You can utilize the following single character keyboard shortcuts to enable alternate display modes (@xie2018r):

* A: Switches show of current versus all slides (helpful for printing all pages)

* B: Make fonts large

* c: Show table of contents

* S: Make fonts smaller






